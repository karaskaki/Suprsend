var socket_ioClient = require('socket.io-client');
var vanilla = require('zustand/vanilla');
var mitt = require('mitt');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var mitt__default = /*#__PURE__*/_interopDefaultLegacy(mitt);

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var SuprSendError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(SuprSendError, _Error);
  function SuprSendError(message) {
    var _this;
    _this = _Error.call(this, message) || this;
    _this.name = void 0;
    _this.name = 'SuprSendError';
    return _this;
  }
  return SuprSendError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
function epochNow() {
  return Math.round(Date.now());
}
function uuid() {
  var dt = new Date().getTime();
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
  return uuid;
}

var configurationStore = vanilla.createStore()(function () {
  return {
    apiUrl: 'https://inboxs.live',
    collectorApiUrl: 'https://hub.suprsend.com',
    socketUrl: 'https://betainbox.suprsend.com',
    pageSize: 20
  };
});
var initialNotificationStore = {
  unseenCount: 0,
  stores: {},
  activeStoreId: null,
  pageNumber: 1,
  hasNext: true,
  initialLoading: false,
  fetchMoreLoading: false,
  initialFetchTime: null
};
var notificationStore = vanilla.createStore()(function () {
  return initialNotificationStore;
});

function _catch$1(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
var ApiClient = /*#__PURE__*/function () {
  function ApiClient(config) {
    this.socket = void 0;
    this.config = void 0;
    this.config = config;
    var configStore = configurationStore.getState();
    this.socket = socket_ioClient.io(configStore.socketUrl, {
      transports: ['websocket'],
      auth: {
        subscriber_id: this.config.subscriberId,
        distinct_id: this.config.distinctId,
        authorization: this.config.workspaceKey + ":" + uuid(),
        tenant_id: this.config.tenantId
      },
      reconnectionAttempts: 25,
      reconnectionDelay: 5000,
      reconnectionDelayMax: 10000
    });
    this._initializeSocketEvents();
  }
  var _proto = ApiClient.prototype;
  _proto.orderNotifications = function orderNotifications(newNotification, oldNotifications) {
    // if pinned notification add new notification at start else at end of pinned notifications
    if (newNotification.is_pinned) {
      return [newNotification].concat(oldNotifications);
    } else {
      var addedNotification = false;
      var notifications = [];
      oldNotifications.forEach(function (notification) {
        if (notification.is_pinned) {
          notifications.push(notification);
        } else {
          if (addedNotification) {
            notifications.push(notification);
          } else {
            notifications.push(newNotification);
            notifications.push(notification);
            addedNotification = true;
          }
        }
      });
      if (!addedNotification) {
        return [].concat(oldNotifications, [newNotification]);
      }
      return notifications;
    }
  };
  _proto._initializeSocketEvents = function _initializeSocketEvents() {
    var _this = this,
      _this2 = this,
      _this3 = this,
      _this4 = this;
    this.socket.on('new_notification', function (data) {
      try {
        if (!data.n_id) return Promise.resolve();
        setTimeout(function () {
          try {
            return Promise.resolve(_catch$1(function () {
              return Promise.resolve(_this.getNotificationDetails(data.n_id)).then(function (response) {
                return Promise.resolve(response.json()).then(function (resData) {
                  var notifStore = notificationStore.getState();
                  if (_this.config.stores) {
                    var overallCountUpdate = false;
                    for (var _iterator = _createForOfIteratorHelperLoose(_this.config.stores), _step; !(_step = _iterator()).done;) {
                      var store = _step.value;
                      var storeData = notifStore.stores[store.storeId];
                      if (_this._notificationBelongToStore(resData.data, store)) {
                        overallCountUpdate = true;
                        storeData.notifications = _this.orderNotifications(resData.data, storeData.notifications);
                        storeData.unseenCount += 1;
                      }
                    }
                    if (overallCountUpdate) {
                      notifStore.unseenCount += 1;
                      _this.config.emitter.emit('new_notification', resData.data);
                    }
                    notificationStore.setState({
                      unseenCount: notifStore.unseenCount,
                      stores: _extends({}, notifStore.stores)
                    });
                  } else {
                    if (!notifStore.activeStoreId) return;
                    var defaultStore = notifStore.stores[notifStore.activeStoreId];
                    notifStore.unseenCount += 1;
                    defaultStore.unseenCount += 1;
                    defaultStore.notifications = _this.orderNotifications(resData.data, defaultStore.notifications);
                    notificationStore.setState({
                      unseenCount: notifStore.unseenCount,
                      stores: _extends({}, notifStore.stores)
                    });
                    _this.config.emitter.emit('new_notification', resData.data);
                  }
                  _this.config.emitter.emit('sync_notif_store');
                });
              });
            }, function (e) {
              console.log('SuprSend: error in new_notification event', e);
            }));
          } catch (e) {
            return Promise.reject(e);
          }
        }, 1000);
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
    this.socket.on('notification_updated', function (data) {
      try {
        if (!data.n_id) return Promise.resolve();
        setTimeout(function () {
          try {
            return Promise.resolve(_catch$1(function () {
              return Promise.resolve(Promise.allSettled([_this2.getNotificationDetails(data.n_id), _this2.getNotificationsCount()])).then(function (apiCalls) {
                var _exit;
                function _temp4(_result3) {
                  if (_exit) return _result3;
                  function _temp2() {
                    _this2.config.emitter.emit('sync_notif_store');
                  }
                  var _temp = function () {
                    if (apiCalls[1].status === 'fulfilled') {
                      var countResponse = apiCalls[1].value;
                      return Promise.resolve(countResponse.json()).then(function (countData) {
                        notificationStore.setState(function (prevState) {
                          for (var storeId in prevState.stores) {
                            var store = prevState.stores[storeId];
                            store.unseenCount = countData[storeId] || 0;
                          }
                          return {
                            unseenCount: countData.ss_bell_count,
                            stores: _extends({}, prevState.stores)
                          };
                        });
                      });
                    }
                  }();
                  return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
                }
                var notifStore = notificationStore.getState();
                var activeStoreId = notifStore.activeStoreId;
                var _temp3 = function () {
                  if (apiCalls[0].status === 'fulfilled') {
                    var response = apiCalls[0].value;
                    return Promise.resolve(response.json()).then(function (resData) {
                      var _this2$config$stores;
                      var newNotificationData = resData.data;
                      if (!activeStoreId) {
                        _exit = 1;
                        return;
                      }
                      var activeStore = notifStore.stores[activeStoreId];
                      var activeStoreQueryData = (_this2$config$stores = _this2.config.stores) == null ? void 0 : _this2$config$stores.find(function (store) {
                        return store.storeId === activeStoreId;
                      });
                      if ((data == null ? void 0 : data.type) === 'archive') {
                        var _activeStoreQueryData;
                        if (activeStoreQueryData != null && (_activeStoreQueryData = activeStoreQueryData.query) != null && _activeStoreQueryData.archived) {
                          if (_this2._notificationBelongToStore(newNotificationData, activeStoreQueryData)) {
                            notifStore.stores[activeStoreId].notifications = [newNotificationData].concat(activeStore.notifications);
                          }
                        } else {
                          notifStore.stores[activeStoreId].notifications = activeStore.notifications.filter(function (notification) {
                            return notification.n_id !== data.n_id;
                          });
                        }
                      } else {
                        notifStore.stores[activeStoreId].notifications = activeStore.notifications.map(function (notification) {
                          return notification.n_id === data.n_id ? resData.data : notification;
                        });
                      }
                      notificationStore.setState({
                        stores: _extends({}, notifStore.stores)
                      });
                    });
                  }
                }();
                return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
              });
            }, function (e) {
              console.log('SuprSend: error in notification_updated event', e);
            }));
          } catch (e) {
            return Promise.reject(e);
          }
        }, 1000);
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
    this.socket.on('update_badge', function () {
      try {
        notificationStore.setState({
          unseenCount: 0
        });
        _this3.config.emitter.emit('sync_notif_store');
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
    this.socket.on('mark_all_read', function () {
      try {
        var notifStore = notificationStore.getState();
        var clickedOn = epochNow();
        for (var storeId in notifStore.stores) {
          var store = notifStore.stores[storeId];
          store.notifications.forEach(function (notification) {
            if (!notification.seen_on) {
              notification.seen_on = clickedOn;
            }
          });
          store.unseenCount = 0;
        }
        notificationStore.setState({
          stores: notifStore.stores
        });
        _this4.config.emitter.emit('sync_notif_store');
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
  };
  _proto._notificationBelongToStore = function _notificationBelongToStore(notification, store) {
    var _store$query, _store$query2, _store$query3, _store$query4;
    var notifRead = !!notification.seen_on;
    var notifArchived = notification.archived;
    var notifTags = notification.tags;
    var notifCategory = notification.n_category;
    var storeRead = store == null ? void 0 : (_store$query = store.query) == null ? void 0 : _store$query.read;
    var storeArchived = store == null ? void 0 : (_store$query2 = store.query) == null ? void 0 : _store$query2.archived;
    var storeTags = store == null ? void 0 : (_store$query3 = store.query) == null ? void 0 : _store$query3.tags;
    var storeCategories = store == null ? void 0 : (_store$query4 = store.query) == null ? void 0 : _store$query4.categories;
    var sameRead = !storeRead || notifRead === storeRead;
    var sameArchived = !storeArchived || notifArchived === storeArchived;
    var sameTags, sameCategory;
    if (Array.isArray(storeTags) && storeTags.length > 0) {
      storeTags.forEach(function (tag) {
        if (notifTags != null && notifTags.includes(tag)) {
          sameTags = true;
        }
      });
    } else {
      sameTags = true;
    }
    if (Array.isArray(storeCategories) && storeCategories.length > 0) {
      if (storeCategories.includes(notifCategory)) {
        sameCategory = true;
      }
    } else {
      sameCategory = true;
    }
    return sameRead && sameTags && sameCategory && sameArchived;
  };
  _proto._getStoreQueryString = function _getStoreQueryString(store) {
    var query = store == null ? void 0 : store.query;
    var tags = (query == null ? void 0 : query.tags) || [];
    var categories = (query == null ? void 0 : query.categories) || [];
    var read = query == null ? void 0 : query.read;
    var archived = query == null ? void 0 : query.archived;
    return {
      store_id: store.storeId,
      query: {
        read: read,
        archived: archived,
        tags: {
          or: tags
        },
        categories: {
          or: categories
        }
      }
    };
  };
  _proto._getStoresQueryString = function _getStoresQueryString() {
    var _this5 = this;
    var stores = this.config.stores;
    var apiStores = stores == null ? void 0 : stores.map(function (store) {
      return _this5._getStoreQueryString(store);
    });
    return apiStores;
  };
  _proto.getNotificationsCount = function getNotificationsCount() {
    var _configurationStore$g = configurationStore.getState(),
      apiUrl = _configurationStore$g.apiUrl;
    var route = "/notification_count/?subscriber_id=" + this.config.subscriberId + "&distinct_id=" + this.config.distinctId + "&tenant_id=" + this.config.tenantId;
    if (this.config.stores) {
      var storedFilter = this._getStoresQueryString();
      route += "&stores=" + encodeURIComponent(JSON.stringify(storedFilter));
    }
    return fetch("" + apiUrl + route, {
      method: 'GET',
      headers: {
        Authorization: this.config.workspaceKey + ":" + uuid()
      }
    });
  };
  _proto.getNotifications = function getNotifications(store, page_no, page_size, before) {
    if (page_size === void 0) {
      page_size = 20;
    }
    var _configurationStore$g2 = configurationStore.getState(),
      apiUrl = _configurationStore$g2.apiUrl;
    var route = "/notifications/?subscriber_id=" + this.config.subscriberId + "&distinct_id=" + this.config.distinctId + "&tenant_id=" + this.config.tenantId + "&page_no=" + page_no + "&page_size=" + page_size + "&before=" + before;
    if (store) {
      var storedFilter = this._getStoreQueryString(store);
      route += "&store=" + encodeURIComponent(JSON.stringify(storedFilter));
    }
    return fetch("" + apiUrl + route, {
      method: 'GET',
      headers: {
        Authorization: this.config.workspaceKey + ":" + uuid()
      }
    });
  };
  _proto.getNotificationDetails = function getNotificationDetails(notification_id) {
    var _configurationStore$g3 = configurationStore.getState(),
      apiUrl = _configurationStore$g3.apiUrl;
    var route = "/notification/" + notification_id + "/?subscriber_id=" + this.config.subscriberId + "&distinct_id=" + this.config.distinctId + "&tenant_id=" + this.config.tenantId;
    return fetch("" + apiUrl + route, {
      method: 'GET',
      headers: {
        Authorization: this.config.workspaceKey + ":" + uuid()
      }
    });
  };
  _proto.markBellClicked = function markBellClicked() {
    var _configurationStore$g4 = configurationStore.getState(),
      apiUrl = _configurationStore$g4.apiUrl;
    var route = '/bell-clicked/';
    var body = JSON.stringify({
      time: epochNow(),
      distinct_id: this.config.distinctId,
      subscriber_id: this.config.subscriberId,
      tenant_id: this.config.tenantId
    });
    return fetch("" + apiUrl + route, {
      method: 'POST',
      body: body,
      headers: {
        Authorization: this.config.workspaceKey + ":" + uuid(),
        'Content-Type': 'application/json'
      }
    });
  };
  _proto.markAllRead = function markAllRead() {
    var _configurationStore$g5 = configurationStore.getState(),
      apiUrl = _configurationStore$g5.apiUrl;
    var route = '/mark-all-read/';
    var body = JSON.stringify({
      time: epochNow(),
      distinct_id: this.config.distinctId,
      subscriber_id: this.config.subscriberId,
      tenant_id: this.config.tenantId
    });
    return fetch("" + apiUrl + route, {
      method: 'POST',
      body: body,
      headers: {
        Authorization: this.config.workspaceKey + ":" + uuid(),
        'Content-Type': 'application/json'
      }
    });
  };
  _proto.markNotificationClicked = function markNotificationClicked(id) {
    var _configurationStore$g6 = configurationStore.getState(),
      collectorApiUrl = _configurationStore$g6.collectorApiUrl;
    var body = {
      event: '$notification_clicked',
      env: this.config.workspaceKey,
      $insert_id: uuid(),
      $time: epochNow(),
      properties: {
        id: id
      }
    };
    return fetch(collectorApiUrl + "/event/", {
      method: 'POST',
      body: JSON.stringify(body),
      headers: {
        Authorization: this.config.workspaceKey + ":",
        'Content-Type': 'application/json'
      }
    });
  };
  _proto.markNotificationRead = function markNotificationRead(id) {
    var _configurationStore$g7 = configurationStore.getState(),
      apiUrl = _configurationStore$g7.apiUrl;
    return fetch(apiUrl + "/notification/" + id + "/action", {
      method: 'POST',
      body: JSON.stringify({
        action: 'read',
        distinct_id: this.config.distinctId,
        subscriber_id: this.config.subscriberId
      }),
      headers: {
        Authorization: this.config.workspaceKey + ":",
        'Content-Type': 'application/json'
      }
    });
  };
  _proto.markNotificationUnRead = function markNotificationUnRead(id) {
    var _configurationStore$g8 = configurationStore.getState(),
      apiUrl = _configurationStore$g8.apiUrl;
    return fetch(apiUrl + "/notification/" + id + "/action", {
      method: 'POST',
      body: JSON.stringify({
        action: 'unread',
        distinct_id: this.config.distinctId,
        subscriber_id: this.config.subscriberId
      }),
      headers: {
        Authorization: this.config.workspaceKey + ":",
        'Content-Type': 'application/json'
      }
    });
  };
  _proto.markNotificationArchive = function markNotificationArchive(id) {
    var _configurationStore$g9 = configurationStore.getState(),
      apiUrl = _configurationStore$g9.apiUrl;
    return fetch(apiUrl + "/notification/" + id + "/action", {
      method: 'POST',
      body: JSON.stringify({
        action: 'archive',
        distinct_id: this.config.distinctId,
        subscriber_id: this.config.subscriberId
      }),
      headers: {
        Authorization: this.config.workspaceKey + ":",
        'Content-Type': 'application/json'
      }
    });
  };
  return ApiClient;
}();

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
var Inbox = /*#__PURE__*/function () {
  function Inbox(config) {
    this.config = void 0;
    this.config = config;
  }
  var _proto = Inbox.prototype;
  _proto._overallFirstApiCall = function _overallFirstApiCall() {
    var notifStore = notificationStore.getState();
    for (var storeId in notifStore.stores) {
      var store = notifStore.stores[storeId];
      if (store.isFirstCall === false) {
        return false;
      }
    }
    return true;
  };
  _proto.fetchNotifications = function fetchNotifications() {
    try {
      var _notifStore$stores, _this$config$stores;
      var _this = this;
      var apiClient = _this.config.client;
      var notifStore = notificationStore.getState();
      var configStore = configurationStore.getState();
      var activeStoreId = notifStore.activeStoreId;
      if (!activeStoreId || !((_notifStore$stores = notifStore.stores) != null && _notifStore$stores[activeStoreId])) return Promise.resolve();
      var storeData = notifStore.stores[activeStoreId];
      var isFirstTime = storeData.isFirstCall;
      var initialFetchTime = notifStore.initialFetchTime || Date.now();
      var storeQuery = (_this$config$stores = _this.config.stores) == null ? void 0 : _this$config$stores.find(function (store) {
        return store.storeId === activeStoreId;
      });
      return Promise.resolve(_catch(function () {
        if (!apiClient || !notifStore.hasNext) return;
        if (isFirstTime) {
          notificationStore.setState({
            initialLoading: true
          });
          if (_this._overallFirstApiCall()) {
            _this.getNotificationsCount();
          }
        } else if (notifStore.pageNumber > 1) {
          notificationStore.setState({
            fetchMoreLoading: true
          });
        }
        _this.config.emitter.emit('sync_notif_store');
        return Promise.resolve(apiClient.getNotifications(storeQuery, notifStore.pageNumber, configStore.pageSize, initialFetchTime)).then(function (response) {
          return Promise.resolve(response.json()).then(function (data) {
            var newNotifications;
            if (isFirstTime || !isFirstTime && notifStore.pageNumber === 1) {
              newNotifications = data.results;
            } else {
              newNotifications = [].concat(storeData.notifications, data.results);
            }
            notifStore.stores[activeStoreId].notifications = newNotifications;
            notifStore.stores[activeStoreId].isFirstCall = false;
            notificationStore.setState({
              stores: notifStore.stores,
              pageNumber: notifStore.pageNumber + 1,
              hasNext: data.meta.current_page < data.meta.total_pages,
              initialFetchTime: initialFetchTime,
              initialLoading: false,
              fetchMoreLoading: false
            });
            _this.config.emitter.emit('sync_notif_store');
            _this.config._startExipryCheck();
          });
        });
      }, function (e) {
        console.log('SUPRSEND: error getting latest notifications', e);
        notificationStore.setState({
          initialLoading: false,
          fetchMoreLoading: false
        });
        _this.config.emitter.emit('sync_notif_store');
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.getNotificationsCount = function getNotificationsCount() {
    try {
      var _this2 = this;
      var apiClient = _this2.config.client;
      if (!apiClient) return Promise.resolve();
      var _temp = _catch(function () {
        return Promise.resolve(apiClient.getNotificationsCount()).then(function (response) {
          return Promise.resolve(response.json()).then(function (data) {
            notificationStore.setState(function (prevState) {
              for (var storeId in prevState.stores) {
                var store = prevState.stores[storeId];
                store.unseenCount = data[storeId] || 0;
              }
              return {
                unseenCount: data.ss_bell_count,
                stores: _extends({}, prevState.stores)
              };
            });
            _this2.config.emitter.emit('sync_notif_store');
          });
        });
      }, function (e) {
        console.log('SUPRSEND: error getting notifications count', e);
      });
      return Promise.resolve(_temp && _temp.then ? _temp.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.markClicked = function markClicked(id) {
    try {
      var _notifStore$stores2;
      var _this3 = this;
      var apiClient = _this3.config.client;
      var notifStore = notificationStore.getState();
      var activeStoreId = notifStore.activeStoreId;
      if (!activeStoreId || !((_notifStore$stores2 = notifStore.stores) != null && _notifStore$stores2[activeStoreId])) return Promise.resolve();
      var storeData = notifStore.stores[activeStoreId];
      var notifications = storeData.notifications;
      var clickedNotification = notifications.find(function (item) {
        return item.n_id === id;
      });
      if (clickedNotification && (!clickedNotification.interacted_on || !clickedNotification.seen_on)) {
        if (!apiClient) return Promise.resolve();
        try {
          if (!clickedNotification.interacted_on) {
            apiClient.markNotificationClicked(id);
          } else if (!clickedNotification.seen_on) {
            apiClient.markNotificationRead(id);
          }
          var clickedOn = epochNow();
          clickedNotification.interacted_on = clickedOn;
          if (!clickedNotification.seen_on) {
            var _loop = function _loop() {
              var _store$notifications;
              var store = notifStore.stores[storeId];
              (_store$notifications = store.notifications) == null ? void 0 : _store$notifications.forEach(function (item) {
                if (item.n_id === clickedNotification.n_id) {
                  item.seen_on = clickedOn;
                  item.interacted_on = clickedOn;
                  if (store.unseenCount > 0) {
                    store.unseenCount -= 1;
                  }
                }
              });
            };
            for (var storeId in notifStore == null ? void 0 : notifStore.stores) {
              _loop();
            }
          }
          notificationStore.setState(_extends({}, notifStore));
          _this3.config.emitter.emit('sync_notif_store');
        } catch (e) {
          console.log('SUPRSEND: error marking notification clicked', e);
        }
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.markAllSeen = function markAllSeen() {
    try {
      var _this4 = this;
      var apiClient = _this4.config.client;
      try {
        if (!apiClient) return Promise.resolve();
        apiClient.markBellClicked();
        notificationStore.setState({
          unseenCount: 0
        });
        _this4.config.emitter.emit('sync_notif_store');
      } catch (e) {
        console.log('SUPRSEND: error marking all notifications seen', e);
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.markAllRead = function markAllRead() {
    try {
      var _this5 = this;
      var apiClient = _this5.config.client;
      try {
        if (!apiClient) return Promise.resolve();
        apiClient.markAllRead();
        var notifStore = notificationStore.getState();
        var clickedOn = epochNow();
        for (var storeId in notifStore.stores) {
          var store = notifStore.stores[storeId];
          store.notifications.forEach(function (notification) {
            if (!notification.seen_on) {
              notification.seen_on = clickedOn;
            }
          });
          store.unseenCount = 0;
        }
        notificationStore.setState({
          stores: notifStore.stores
        });
        _this5.config.emitter.emit('sync_notif_store');
      } catch (e) {
        console.log('SUPRSEND: error marking all notifications read', e);
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.markRead = function markRead(id) {
    try {
      var _notifStore$stores3;
      var _this6 = this;
      var apiClient = _this6.config.client;
      var notifStore = notificationStore.getState();
      var activeStoreId = notifStore.activeStoreId;
      if (!activeStoreId || !((_notifStore$stores3 = notifStore.stores) != null && _notifStore$stores3[activeStoreId])) return Promise.resolve();
      var storeData = notifStore.stores[activeStoreId];
      var notifications = storeData.notifications;
      var clickedNotification = notifications.find(function (item) {
        return item.n_id === id;
      });
      if (clickedNotification && !clickedNotification.seen_on) {
        if (!apiClient) return Promise.resolve();
        try {
          apiClient.markNotificationRead(id);
          var clickedOn = epochNow();
          if (!clickedNotification.seen_on) {
            var _loop2 = function _loop2() {
              var _store$notifications2;
              var store = notifStore.stores[storeId];
              (_store$notifications2 = store.notifications) == null ? void 0 : _store$notifications2.forEach(function (item) {
                if (item.n_id === clickedNotification.n_id) {
                  item.seen_on = clickedOn;
                  if (store.unseenCount > 0) {
                    store.unseenCount -= 1;
                  }
                }
              });
            };
            for (var storeId in notifStore == null ? void 0 : notifStore.stores) {
              _loop2();
            }
          }
          notificationStore.setState(_extends({}, notifStore));
          _this6.config.emitter.emit('sync_notif_store');
        } catch (e) {
          console.log('SUPRSEND: error marking notification read', e);
        }
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.markUnRead = function markUnRead(id) {
    try {
      var _notifStore$stores4;
      var _this7 = this;
      var apiClient = _this7.config.client;
      var notifStore = notificationStore.getState();
      var activeStoreId = notifStore.activeStoreId;
      if (!activeStoreId || !((_notifStore$stores4 = notifStore.stores) != null && _notifStore$stores4[activeStoreId])) return Promise.resolve();
      var storeData = notifStore.stores[activeStoreId];
      var notifications = storeData.notifications;
      var clickedNotification = notifications.find(function (item) {
        return item.n_id === id;
      });
      if (clickedNotification && clickedNotification.seen_on) {
        if (!apiClient) return Promise.resolve();
        try {
          apiClient.markNotificationUnRead(id);
          if (clickedNotification.seen_on) {
            var _loop3 = function _loop3() {
              var _store$notifications3;
              var store = notifStore.stores[storeId];
              (_store$notifications3 = store.notifications) == null ? void 0 : _store$notifications3.forEach(function (item) {
                if (item.n_id === clickedNotification.n_id) {
                  item.seen_on = undefined;
                  if (store.unseenCount >= 0) {
                    store.unseenCount += 1;
                  }
                }
              });
            };
            for (var storeId in notifStore == null ? void 0 : notifStore.stores) {
              _loop3();
            }
          }
          notificationStore.setState(_extends({}, notifStore));
          _this7.config.emitter.emit('sync_notif_store');
        } catch (e) {
          console.log('SUPRSEND: error marking notification read', e);
        }
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.markArchived = function markArchived(id) {
    var _notifStore$stores5;
    var apiClient = this.config.client;
    var notifStore = notificationStore.getState();
    var activeStoreId = notifStore.activeStoreId;
    if (!activeStoreId || !((_notifStore$stores5 = notifStore.stores) != null && _notifStore$stores5[activeStoreId])) return;
    var stores = notifStore == null ? void 0 : notifStore.stores;
    var storeData = stores[activeStoreId];
    var clickedNotification = storeData.notifications.find(function (item) {
      return item.n_id === id;
    });
    if (clickedNotification && !clickedNotification.archived) {
      if (!apiClient) return;
      try {
        apiClient.markNotificationArchive(id);
        storeData.notifications = storeData.notifications.filter(function (notification) {
          return notification.n_id !== id;
        });
        if (!clickedNotification.seen_on && storeData.unseenCount > 0) {
          storeData.unseenCount -= 1;
        }
        notificationStore.setState(_extends({}, notifStore));
        this.config.emitter.emit('sync_notif_store');
      } catch (e) {
        console.log('SUPRSEND: error marking notification archived', e);
      }
    }
  };
  _createClass(Inbox, [{
    key: "stores",
    get: function get() {
      return this.config.stores;
    }
  }, {
    key: "data",
    get: function get() {
      var notifStore = notificationStore.getState();
      var activeStoreId = notifStore.activeStoreId;
      var storeFilters = this.stores;
      if (!activeStoreId) return;
      return {
        unseenCount: notifStore.unseenCount,
        activeStoreId: notifStore.activeStoreId,
        stores: notifStore.stores,
        hasStores: storeFilters ? (storeFilters == null ? void 0 : storeFilters.length) > 0 : false,
        hasNext: notifStore.hasNext,
        initialLoading: notifStore.initialLoading,
        fetchMoreLoading: notifStore.fetchMoreLoading
      };
    }
  }]);
  return Inbox;
}();

var SuprSendInbox = /*#__PURE__*/function () {
  function SuprSendInbox(workspaceKey, config) {
    this.workspaceKey = '';
    this.tenantId = void 0;
    this.stores = void 0;
    this.distinctId = void 0;
    this.subscriberId = void 0;
    this._client = void 0;
    this._expiryTimerId = void 0;
    this.feed = new Inbox(this);
    this.emitter = mitt__default["default"]();
    this._validateConfig(workspaceKey);
    this.tenantId = (config == null ? void 0 : config.tenantID) || 'default';
    this._validateStore(config == null ? void 0 : config.stores);
    this._validatePageSize(config == null ? void 0 : config.pageSize);
    this._initializeStoreState();
  }
  var _proto = SuprSendInbox.prototype;
  _proto._validateConfig = function _validateConfig(workspaceKey) {
    if (!workspaceKey) {
      throw new SuprSendError('workspaceKey missing');
    } else {
      this.workspaceKey = workspaceKey;
    }
  };
  _proto._validateStore = function _validateStore(stores) {
    if (!stores || !Array.isArray(stores)) return;
    var validatedStores = [];
    stores.forEach(function (store) {
      if (!store.storeId) {
        console.log('SuprSendInbox: storeId is mandatory if stores are used');
        return;
      }
      var query = store == null ? void 0 : store.query;
      var read;
      var tags = [];
      var categories = [];
      var archived;
      if (typeof (query == null ? void 0 : query.read) === 'boolean') {
        read = query.read;
      }
      if (typeof (query == null ? void 0 : query.archived) === 'boolean') {
        archived = query.archived;
      }
      if (typeof (query == null ? void 0 : query.tags) === 'string') {
        tags = [query.tags];
      } else if (Array.isArray(query == null ? void 0 : query.tags)) {
        tags = query == null ? void 0 : query.tags.filter(function (tag) {
          return typeof tag === 'string';
        });
      }
      if (typeof (query == null ? void 0 : query.categories) === 'string') {
        categories = [query.categories];
      } else if (Array.isArray(query == null ? void 0 : query.categories)) {
        categories = query == null ? void 0 : query.categories.filter(function (category) {
          return typeof category === 'string';
        });
      }
      validatedStores.push({
        storeId: store.storeId,
        label: store.label || store.storeId,
        query: {
          archived: archived,
          read: read,
          tags: tags,
          categories: categories
        }
      });
    });
    this.stores = validatedStores;
  };
  _proto._validatePageSize = function _validatePageSize(pageSize) {
    if (pageSize && typeof pageSize === 'number') {
      var MAX_ALLOWED_PAGE_SIZE = 50;
      var validatedPageSize = pageSize <= MAX_ALLOWED_PAGE_SIZE ? pageSize : MAX_ALLOWED_PAGE_SIZE;
      configurationStore.setState({
        pageSize: validatedPageSize
      });
    }
  };
  _proto._initializeStoreState = function _initializeStoreState() {
    var _this = this;
    var default_store = 'default_store';
    var initialStoreData = {
      notifications: [],
      unseenCount: 0,
      isFirstCall: true
    };
    if (this.stores && Array.isArray(this.stores) && this.stores.length > 0) {
      var finalStores = {};
      this.stores.map(function (store) {
        finalStores[store.storeId] = _extends({}, initialStoreData);
      });
      notificationStore.setState({
        stores: finalStores,
        activeStoreId: this.stores[0].storeId
      });
    } else {
      var _stores;
      notificationStore.setState({
        stores: (_stores = {}, _stores[default_store] = _extends({}, initialStoreData), _stores),
        activeStoreId: default_store
      });
    }
    // needed as wait for even listener to register after initialization
    setTimeout(function () {
      _this.emitter.emit('sync_notif_store');
    }, 0);
  };
  _proto._startExipryCheck = function _startExipryCheck() {
    var _this2 = this;
    if (this._expiryTimerId) return;
    this._expiryTimerId = setInterval(function () {
      try {
        var notifData = notificationStore.getState();
        var storeNotifsData = notifData.stores;
        var hasExpired = false;
        for (var store in storeNotifsData) {
          var notifications = storeNotifsData[store].notifications;
          notifications = notifications.filter(function (notification) {
            var expired = notification.expiry ? Date.now() > notification.expiry : false;
            if (expired) {
              hasExpired = true;
              return false;
            } else {
              return true;
            }
          });
          storeNotifsData[store].notifications = notifications;
        }
        var _temp = function () {
          if (hasExpired) {
            notificationStore.setState({
              stores: storeNotifsData
            });
            return Promise.resolve(_this2.feed.getNotificationsCount()).then(function () {
              _this2.emitter.emit('sync_notif_store');
            });
          }
        }();
        return Promise.resolve(_temp && _temp.then ? _temp.then(function () {}) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    }, 30000);
  };
  _proto.identifyUser = function identifyUser(distinctId, subscriberId) {
    this.distinctId = distinctId;
    this.subscriberId = subscriberId;
  };
  _proto.changeActiveStore = function changeActiveStore(storeId) {
    var _storeData$stores;
    var storeData = notificationStore.getState();
    var newStores = {};
    if (storeData.activeStoreId === storeId) return;
    if (!((_storeData$stores = storeData.stores) != null && _storeData$stores[storeId])) return;
    for (var _storeId in storeData.stores) {
      var store = storeData.stores[_storeId];
      var storeNotifications = store.notifications.slice(0, 20);
      newStores[_storeId] = {
        notifications: storeNotifications,
        unseenCount: store.unseenCount,
        isFirstCall: store.isFirstCall
      };
    }
    notificationStore.setState({
      activeStoreId: storeId,
      stores: newStores,
      pageNumber: 1,
      hasNext: true,
      initialLoading: false,
      fetchMoreLoading: false,
      initialFetchTime: null
    });
    if (this.client) {
      this.feed.fetchNotifications();
    }
  };
  _proto.resetUser = function resetUser() {
    var _this$_client;
    notificationStore.setState({
      unseenCount: 0,
      pageNumber: 1,
      hasNext: true,
      initialLoading: false,
      fetchMoreLoading: false,
      initialFetchTime: null
    });
    this._initializeStoreState();
    (_this$_client = this._client) == null ? void 0 : _this$_client.socket.disconnect();
    this.distinctId = undefined;
    this.subscriberId = undefined;
    this._client = undefined;
    clearInterval(this._expiryTimerId);
    this._expiryTimerId = undefined;
    this.feed = new Inbox(this);
  };
  _createClass(SuprSendInbox, [{
    key: "client",
    get: function get() {
      if (this.distinctId && this.subscriberId) {
        if (!this._client) {
          this._client = new ApiClient(this);
        }
      }
      return this._client;
    }
  }]);
  return SuprSendInbox;
}();

module.exports = SuprSendInbox;
//# sourceMappingURL=index.cjs.map
