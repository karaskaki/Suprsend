import { io } from 'socket.io-client';
import { createStore } from 'zustand/vanilla';
import mitt from 'mitt';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

class SuprSendError extends Error {
  constructor(message) {
    super(message);
    this.name = void 0;
    this.name = 'SuprSendError';
  }
}
function epochNow() {
  return Math.round(Date.now());
}
function uuid() {
  var dt = new Date().getTime();
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
  return uuid;
}

const configurationStore = createStore()(() => ({
  apiUrl: 'https://inboxs.live',
  collectorApiUrl: 'https://hub.suprsend.com',
  socketUrl: 'https://betainbox.suprsend.com',
  pageSize: 20
}));
const initialNotificationStore = {
  unseenCount: 0,
  stores: {},
  activeStoreId: null,
  pageNumber: 1,
  hasNext: true,
  initialLoading: false,
  fetchMoreLoading: false,
  initialFetchTime: null
};
const notificationStore = createStore()(() => initialNotificationStore);

class ApiClient {
  constructor(config) {
    this.socket = void 0;
    this.config = void 0;
    this.config = config;
    const configStore = configurationStore.getState();
    this.socket = io(configStore.socketUrl, {
      transports: ['websocket'],
      auth: {
        subscriber_id: this.config.subscriberId,
        distinct_id: this.config.distinctId,
        authorization: `${this.config.workspaceKey}:${uuid()}`,
        tenant_id: this.config.tenantId
      },
      reconnectionAttempts: 25,
      reconnectionDelay: 5000,
      reconnectionDelayMax: 10000
    });
    this._initializeSocketEvents();
  }
  orderNotifications(newNotification, oldNotifications) {
    // if pinned notification add new notification at start else at end of pinned notifications
    if (newNotification.is_pinned) {
      return [newNotification, ...oldNotifications];
    } else {
      let addedNotification = false;
      let notifications = [];
      oldNotifications.forEach(notification => {
        if (notification.is_pinned) {
          notifications.push(notification);
        } else {
          if (addedNotification) {
            notifications.push(notification);
          } else {
            notifications.push(newNotification);
            notifications.push(notification);
            addedNotification = true;
          }
        }
      });
      if (!addedNotification) {
        return [...oldNotifications, newNotification];
      }
      return notifications;
    }
  }
  _initializeSocketEvents() {
    var _this = this;
    this.socket.on('new_notification', async function (data) {
      if (!data.n_id) return;
      setTimeout(async function () {
        try {
          const response = await _this.getNotificationDetails(data.n_id);
          const resData = await response.json();
          const notifStore = notificationStore.getState();
          if (_this.config.stores) {
            let overallCountUpdate = false;
            for (let store of _this.config.stores) {
              const storeData = notifStore.stores[store.storeId];
              if (_this._notificationBelongToStore(resData.data, store)) {
                overallCountUpdate = true;
                storeData.notifications = _this.orderNotifications(resData.data, storeData.notifications);
                storeData.unseenCount += 1;
              }
            }
            if (overallCountUpdate) {
              notifStore.unseenCount += 1;
              _this.config.emitter.emit('new_notification', resData.data);
            }
            notificationStore.setState({
              unseenCount: notifStore.unseenCount,
              stores: _extends({}, notifStore.stores)
            });
          } else {
            if (!notifStore.activeStoreId) return;
            let defaultStore = notifStore.stores[notifStore.activeStoreId];
            notifStore.unseenCount += 1;
            defaultStore.unseenCount += 1;
            defaultStore.notifications = _this.orderNotifications(resData.data, defaultStore.notifications);
            notificationStore.setState({
              unseenCount: notifStore.unseenCount,
              stores: _extends({}, notifStore.stores)
            });
            _this.config.emitter.emit('new_notification', resData.data);
          }
          _this.config.emitter.emit('sync_notif_store');
        } catch (e) {
          console.log('SuprSend: error in new_notification event', e);
        }
      }, 1000);
    });
    this.socket.on('notification_updated', async function (data) {
      if (!data.n_id) return;
      setTimeout(async function () {
        try {
          const apiCalls = await Promise.allSettled([_this.getNotificationDetails(data.n_id), _this.getNotificationsCount()]);
          const notifStore = notificationStore.getState();
          let activeStoreId = notifStore.activeStoreId;
          if (apiCalls[0].status === 'fulfilled') {
            var _this$config$stores;
            const response = apiCalls[0].value;
            const resData = await response.json();
            const newNotificationData = resData.data;
            if (!activeStoreId) return;
            let activeStore = notifStore.stores[activeStoreId];
            const activeStoreQueryData = (_this$config$stores = _this.config.stores) == null ? void 0 : _this$config$stores.find(store => store.storeId === activeStoreId);
            if ((data == null ? void 0 : data.type) === 'archive') {
              var _activeStoreQueryData;
              if (activeStoreQueryData != null && (_activeStoreQueryData = activeStoreQueryData.query) != null && _activeStoreQueryData.archived) {
                if (_this._notificationBelongToStore(newNotificationData, activeStoreQueryData)) {
                  notifStore.stores[activeStoreId].notifications = [newNotificationData, ...activeStore.notifications];
                }
              } else {
                notifStore.stores[activeStoreId].notifications = activeStore.notifications.filter(notification => notification.n_id !== data.n_id);
              }
            } else {
              notifStore.stores[activeStoreId].notifications = activeStore.notifications.map(notification => notification.n_id === data.n_id ? resData.data : notification);
            }
            notificationStore.setState({
              stores: _extends({}, notifStore.stores)
            });
          }
          if (apiCalls[1].status === 'fulfilled') {
            const countResponse = apiCalls[1].value;
            const countData = await countResponse.json();
            notificationStore.setState(prevState => {
              for (let storeId in prevState.stores) {
                const store = prevState.stores[storeId];
                store.unseenCount = countData[storeId] || 0;
              }
              return {
                unseenCount: countData.ss_bell_count,
                stores: _extends({}, prevState.stores)
              };
            });
          }
          _this.config.emitter.emit('sync_notif_store');
        } catch (e) {
          console.log('SuprSend: error in notification_updated event', e);
        }
      }, 1000);
    });
    this.socket.on('update_badge', async function () {
      notificationStore.setState({
        unseenCount: 0
      });
      _this.config.emitter.emit('sync_notif_store');
    });
    this.socket.on('mark_all_read', async function () {
      const notifStore = notificationStore.getState();
      const clickedOn = epochNow();
      for (let storeId in notifStore.stores) {
        const store = notifStore.stores[storeId];
        store.notifications.forEach(notification => {
          if (!notification.seen_on) {
            notification.seen_on = clickedOn;
          }
        });
        store.unseenCount = 0;
      }
      notificationStore.setState({
        stores: notifStore.stores
      });
      _this.config.emitter.emit('sync_notif_store');
    });
  }
  _notificationBelongToStore(notification, store) {
    var _store$query, _store$query2, _store$query3, _store$query4;
    const notifRead = !!notification.seen_on;
    const notifArchived = notification.archived;
    const notifTags = notification.tags;
    const notifCategory = notification.n_category;
    const storeRead = store == null ? void 0 : (_store$query = store.query) == null ? void 0 : _store$query.read;
    const storeArchived = store == null ? void 0 : (_store$query2 = store.query) == null ? void 0 : _store$query2.archived;
    const storeTags = store == null ? void 0 : (_store$query3 = store.query) == null ? void 0 : _store$query3.tags;
    const storeCategories = store == null ? void 0 : (_store$query4 = store.query) == null ? void 0 : _store$query4.categories;
    const sameRead = !storeRead || notifRead === storeRead;
    const sameArchived = !storeArchived || notifArchived === storeArchived;
    let sameTags, sameCategory;
    if (Array.isArray(storeTags) && storeTags.length > 0) {
      storeTags.forEach(tag => {
        if (notifTags != null && notifTags.includes(tag)) {
          sameTags = true;
        }
      });
    } else {
      sameTags = true;
    }
    if (Array.isArray(storeCategories) && storeCategories.length > 0) {
      if (storeCategories.includes(notifCategory)) {
        sameCategory = true;
      }
    } else {
      sameCategory = true;
    }
    return sameRead && sameTags && sameCategory && sameArchived;
  }
  _getStoreQueryString(store) {
    const query = store == null ? void 0 : store.query;
    let tags = (query == null ? void 0 : query.tags) || [];
    let categories = (query == null ? void 0 : query.categories) || [];
    const read = query == null ? void 0 : query.read;
    const archived = query == null ? void 0 : query.archived;
    return {
      store_id: store.storeId,
      query: {
        read,
        archived,
        tags: {
          or: tags
        },
        categories: {
          or: categories
        }
      }
    };
  }
  _getStoresQueryString() {
    const stores = this.config.stores;
    let apiStores = stores == null ? void 0 : stores.map(store => {
      return this._getStoreQueryString(store);
    });
    return apiStores;
  }
  getNotificationsCount() {
    const {
      apiUrl
    } = configurationStore.getState();
    let route = `/notification_count/?subscriber_id=${this.config.subscriberId}&distinct_id=${this.config.distinctId}&tenant_id=${this.config.tenantId}`;
    if (this.config.stores) {
      const storedFilter = this._getStoresQueryString();
      route += `&stores=${encodeURIComponent(JSON.stringify(storedFilter))}`;
    }
    return fetch(`${apiUrl}${route}`, {
      method: 'GET',
      headers: {
        Authorization: `${this.config.workspaceKey}:${uuid()}`
      }
    });
  }
  getNotifications(store, page_no, page_size = 20, before) {
    const {
      apiUrl
    } = configurationStore.getState();
    let route = `/notifications/?subscriber_id=${this.config.subscriberId}&distinct_id=${this.config.distinctId}&tenant_id=${this.config.tenantId}&page_no=${page_no}&page_size=${page_size}&before=${before}`;
    if (store) {
      const storedFilter = this._getStoreQueryString(store);
      route += `&store=${encodeURIComponent(JSON.stringify(storedFilter))}`;
    }
    return fetch(`${apiUrl}${route}`, {
      method: 'GET',
      headers: {
        Authorization: `${this.config.workspaceKey}:${uuid()}`
      }
    });
  }
  getNotificationDetails(notification_id) {
    const {
      apiUrl
    } = configurationStore.getState();
    const route = `/notification/${notification_id}/?subscriber_id=${this.config.subscriberId}&distinct_id=${this.config.distinctId}&tenant_id=${this.config.tenantId}`;
    return fetch(`${apiUrl}${route}`, {
      method: 'GET',
      headers: {
        Authorization: `${this.config.workspaceKey}:${uuid()}`
      }
    });
  }
  markBellClicked() {
    const {
      apiUrl
    } = configurationStore.getState();
    const route = '/bell-clicked/';
    const body = JSON.stringify({
      time: epochNow(),
      distinct_id: this.config.distinctId,
      subscriber_id: this.config.subscriberId,
      tenant_id: this.config.tenantId
    });
    return fetch(`${apiUrl}${route}`, {
      method: 'POST',
      body,
      headers: {
        Authorization: `${this.config.workspaceKey}:${uuid()}`,
        'Content-Type': 'application/json'
      }
    });
  }
  markAllRead() {
    const {
      apiUrl
    } = configurationStore.getState();
    const route = '/mark-all-read/';
    const body = JSON.stringify({
      time: epochNow(),
      distinct_id: this.config.distinctId,
      subscriber_id: this.config.subscriberId,
      tenant_id: this.config.tenantId
    });
    return fetch(`${apiUrl}${route}`, {
      method: 'POST',
      body,
      headers: {
        Authorization: `${this.config.workspaceKey}:${uuid()}`,
        'Content-Type': 'application/json'
      }
    });
  }
  markNotificationClicked(id) {
    const {
      collectorApiUrl
    } = configurationStore.getState();
    const body = {
      event: '$notification_clicked',
      env: this.config.workspaceKey,
      $insert_id: uuid(),
      $time: epochNow(),
      properties: {
        id
      }
    };
    return fetch(`${collectorApiUrl}/event/`, {
      method: 'POST',
      body: JSON.stringify(body),
      headers: {
        Authorization: `${this.config.workspaceKey}:`,
        'Content-Type': 'application/json'
      }
    });
  }
  markNotificationRead(id) {
    const {
      apiUrl
    } = configurationStore.getState();
    return fetch(`${apiUrl}/notification/${id}/action`, {
      method: 'POST',
      body: JSON.stringify({
        action: 'read',
        distinct_id: this.config.distinctId,
        subscriber_id: this.config.subscriberId
      }),
      headers: {
        Authorization: `${this.config.workspaceKey}:`,
        'Content-Type': 'application/json'
      }
    });
  }
  markNotificationUnRead(id) {
    const {
      apiUrl
    } = configurationStore.getState();
    return fetch(`${apiUrl}/notification/${id}/action`, {
      method: 'POST',
      body: JSON.stringify({
        action: 'unread',
        distinct_id: this.config.distinctId,
        subscriber_id: this.config.subscriberId
      }),
      headers: {
        Authorization: `${this.config.workspaceKey}:`,
        'Content-Type': 'application/json'
      }
    });
  }
  markNotificationArchive(id) {
    const {
      apiUrl
    } = configurationStore.getState();
    return fetch(`${apiUrl}/notification/${id}/action`, {
      method: 'POST',
      body: JSON.stringify({
        action: 'archive',
        distinct_id: this.config.distinctId,
        subscriber_id: this.config.subscriberId
      }),
      headers: {
        Authorization: `${this.config.workspaceKey}:`,
        'Content-Type': 'application/json'
      }
    });
  }
}

class Inbox {
  constructor(config) {
    this.config = void 0;
    this.config = config;
  }
  _overallFirstApiCall() {
    const notifStore = notificationStore.getState();
    for (let storeId in notifStore.stores) {
      const store = notifStore.stores[storeId];
      if (store.isFirstCall === false) {
        return false;
      }
    }
    return true;
  }
  async fetchNotifications() {
    var _notifStore$stores, _this$config$stores;
    const apiClient = this.config.client;
    const notifStore = notificationStore.getState();
    const configStore = configurationStore.getState();
    const activeStoreId = notifStore.activeStoreId;
    if (!activeStoreId || !((_notifStore$stores = notifStore.stores) != null && _notifStore$stores[activeStoreId])) return;
    const storeData = notifStore.stores[activeStoreId];
    const isFirstTime = storeData.isFirstCall;
    const initialFetchTime = notifStore.initialFetchTime || Date.now();
    const storeQuery = (_this$config$stores = this.config.stores) == null ? void 0 : _this$config$stores.find(store => {
      return store.storeId === activeStoreId;
    });
    try {
      if (!apiClient || !notifStore.hasNext) return;
      if (isFirstTime) {
        notificationStore.setState({
          initialLoading: true
        });
        if (this._overallFirstApiCall()) {
          this.getNotificationsCount();
        }
      } else if (notifStore.pageNumber > 1) {
        notificationStore.setState({
          fetchMoreLoading: true
        });
      }
      this.config.emitter.emit('sync_notif_store');
      const response = await apiClient.getNotifications(storeQuery, notifStore.pageNumber, configStore.pageSize, initialFetchTime);
      const data = await response.json();
      let newNotifications;
      if (isFirstTime || !isFirstTime && notifStore.pageNumber === 1) {
        newNotifications = data.results;
      } else {
        newNotifications = [...storeData.notifications, ...data.results];
      }
      notifStore.stores[activeStoreId].notifications = newNotifications;
      notifStore.stores[activeStoreId].isFirstCall = false;
      notificationStore.setState({
        stores: notifStore.stores,
        pageNumber: notifStore.pageNumber + 1,
        hasNext: data.meta.current_page < data.meta.total_pages,
        initialFetchTime: initialFetchTime,
        initialLoading: false,
        fetchMoreLoading: false
      });
      this.config.emitter.emit('sync_notif_store');
      this.config._startExipryCheck();
    } catch (e) {
      console.log('SUPRSEND: error getting latest notifications', e);
      notificationStore.setState({
        initialLoading: false,
        fetchMoreLoading: false
      });
      this.config.emitter.emit('sync_notif_store');
    }
  }
  async getNotificationsCount() {
    const apiClient = this.config.client;
    if (!apiClient) return;
    try {
      const response = await apiClient.getNotificationsCount();
      const data = await response.json();
      notificationStore.setState(prevState => {
        for (let storeId in prevState.stores) {
          const store = prevState.stores[storeId];
          store.unseenCount = data[storeId] || 0;
        }
        return {
          unseenCount: data.ss_bell_count,
          stores: _extends({}, prevState.stores)
        };
      });
      this.config.emitter.emit('sync_notif_store');
    } catch (e) {
      console.log('SUPRSEND: error getting notifications count', e);
    }
  }
  async markClicked(id) {
    var _notifStore$stores2;
    const apiClient = this.config.client;
    const notifStore = notificationStore.getState();
    const activeStoreId = notifStore.activeStoreId;
    if (!activeStoreId || !((_notifStore$stores2 = notifStore.stores) != null && _notifStore$stores2[activeStoreId])) return;
    const storeData = notifStore.stores[activeStoreId];
    const notifications = storeData.notifications;
    const clickedNotification = notifications.find(item => item.n_id === id);
    if (clickedNotification && (!clickedNotification.interacted_on || !clickedNotification.seen_on)) {
      if (!apiClient) return;
      try {
        if (!clickedNotification.interacted_on) {
          apiClient.markNotificationClicked(id);
        } else if (!clickedNotification.seen_on) {
          apiClient.markNotificationRead(id);
        }
        const clickedOn = epochNow();
        clickedNotification.interacted_on = clickedOn;
        if (!clickedNotification.seen_on) {
          for (let storeId in notifStore == null ? void 0 : notifStore.stores) {
            var _store$notifications;
            const store = notifStore.stores[storeId];
            (_store$notifications = store.notifications) == null ? void 0 : _store$notifications.forEach(item => {
              if (item.n_id === clickedNotification.n_id) {
                item.seen_on = clickedOn;
                item.interacted_on = clickedOn;
                if (store.unseenCount > 0) {
                  store.unseenCount -= 1;
                }
              }
            });
          }
        }
        notificationStore.setState(_extends({}, notifStore));
        this.config.emitter.emit('sync_notif_store');
      } catch (e) {
        console.log('SUPRSEND: error marking notification clicked', e);
      }
    }
  }
  async markAllSeen() {
    const apiClient = this.config.client;
    try {
      if (!apiClient) return;
      apiClient.markBellClicked();
      notificationStore.setState({
        unseenCount: 0
      });
      this.config.emitter.emit('sync_notif_store');
    } catch (e) {
      console.log('SUPRSEND: error marking all notifications seen', e);
    }
  }
  async markAllRead() {
    const apiClient = this.config.client;
    try {
      if (!apiClient) return;
      apiClient.markAllRead();
      const notifStore = notificationStore.getState();
      const clickedOn = epochNow();
      for (let storeId in notifStore.stores) {
        const store = notifStore.stores[storeId];
        store.notifications.forEach(notification => {
          if (!notification.seen_on) {
            notification.seen_on = clickedOn;
          }
        });
        store.unseenCount = 0;
      }
      notificationStore.setState({
        stores: notifStore.stores
      });
      this.config.emitter.emit('sync_notif_store');
    } catch (e) {
      console.log('SUPRSEND: error marking all notifications read', e);
    }
  }
  async markRead(id) {
    var _notifStore$stores3;
    const apiClient = this.config.client;
    const notifStore = notificationStore.getState();
    const activeStoreId = notifStore.activeStoreId;
    if (!activeStoreId || !((_notifStore$stores3 = notifStore.stores) != null && _notifStore$stores3[activeStoreId])) return;
    const storeData = notifStore.stores[activeStoreId];
    const notifications = storeData.notifications;
    const clickedNotification = notifications.find(item => item.n_id === id);
    if (clickedNotification && !clickedNotification.seen_on) {
      if (!apiClient) return;
      try {
        apiClient.markNotificationRead(id);
        const clickedOn = epochNow();
        if (!clickedNotification.seen_on) {
          for (let storeId in notifStore == null ? void 0 : notifStore.stores) {
            var _store$notifications2;
            const store = notifStore.stores[storeId];
            (_store$notifications2 = store.notifications) == null ? void 0 : _store$notifications2.forEach(item => {
              if (item.n_id === clickedNotification.n_id) {
                item.seen_on = clickedOn;
                if (store.unseenCount > 0) {
                  store.unseenCount -= 1;
                }
              }
            });
          }
        }
        notificationStore.setState(_extends({}, notifStore));
        this.config.emitter.emit('sync_notif_store');
      } catch (e) {
        console.log('SUPRSEND: error marking notification read', e);
      }
    }
  }
  async markUnRead(id) {
    var _notifStore$stores4;
    const apiClient = this.config.client;
    const notifStore = notificationStore.getState();
    const activeStoreId = notifStore.activeStoreId;
    if (!activeStoreId || !((_notifStore$stores4 = notifStore.stores) != null && _notifStore$stores4[activeStoreId])) return;
    const storeData = notifStore.stores[activeStoreId];
    const notifications = storeData.notifications;
    const clickedNotification = notifications.find(item => item.n_id === id);
    if (clickedNotification && clickedNotification.seen_on) {
      if (!apiClient) return;
      try {
        apiClient.markNotificationUnRead(id);
        if (clickedNotification.seen_on) {
          for (let storeId in notifStore == null ? void 0 : notifStore.stores) {
            var _store$notifications3;
            const store = notifStore.stores[storeId];
            (_store$notifications3 = store.notifications) == null ? void 0 : _store$notifications3.forEach(item => {
              if (item.n_id === clickedNotification.n_id) {
                item.seen_on = undefined;
                if (store.unseenCount >= 0) {
                  store.unseenCount += 1;
                }
              }
            });
          }
        }
        notificationStore.setState(_extends({}, notifStore));
        this.config.emitter.emit('sync_notif_store');
      } catch (e) {
        console.log('SUPRSEND: error marking notification read', e);
      }
    }
  }
  markArchived(id) {
    var _notifStore$stores5;
    const apiClient = this.config.client;
    const notifStore = notificationStore.getState();
    const activeStoreId = notifStore.activeStoreId;
    if (!activeStoreId || !((_notifStore$stores5 = notifStore.stores) != null && _notifStore$stores5[activeStoreId])) return;
    const stores = notifStore == null ? void 0 : notifStore.stores;
    const storeData = stores[activeStoreId];
    const clickedNotification = storeData.notifications.find(item => item.n_id === id);
    if (clickedNotification && !clickedNotification.archived) {
      if (!apiClient) return;
      try {
        apiClient.markNotificationArchive(id);
        storeData.notifications = storeData.notifications.filter(notification => notification.n_id !== id);
        if (!clickedNotification.seen_on && storeData.unseenCount > 0) {
          storeData.unseenCount -= 1;
        }
        notificationStore.setState(_extends({}, notifStore));
        this.config.emitter.emit('sync_notif_store');
      } catch (e) {
        console.log('SUPRSEND: error marking notification archived', e);
      }
    }
  }
  get stores() {
    return this.config.stores;
  }
  get data() {
    const notifStore = notificationStore.getState();
    const activeStoreId = notifStore.activeStoreId;
    const storeFilters = this.stores;
    if (!activeStoreId) return;
    return {
      unseenCount: notifStore.unseenCount,
      activeStoreId: notifStore.activeStoreId,
      stores: notifStore.stores,
      hasStores: storeFilters ? (storeFilters == null ? void 0 : storeFilters.length) > 0 : false,
      hasNext: notifStore.hasNext,
      initialLoading: notifStore.initialLoading,
      fetchMoreLoading: notifStore.fetchMoreLoading
    };
  }
}

class SuprSendInbox {
  constructor(workspaceKey, config) {
    this.workspaceKey = '';
    this.tenantId = void 0;
    this.stores = void 0;
    this.distinctId = void 0;
    this.subscriberId = void 0;
    this._client = void 0;
    this._expiryTimerId = void 0;
    this.feed = new Inbox(this);
    this.emitter = mitt();
    this._validateConfig(workspaceKey);
    this.tenantId = (config == null ? void 0 : config.tenantID) || 'default';
    this._validateStore(config == null ? void 0 : config.stores);
    this._validatePageSize(config == null ? void 0 : config.pageSize);
    this._initializeStoreState();
  }
  _validateConfig(workspaceKey) {
    if (!workspaceKey) {
      throw new SuprSendError('workspaceKey missing');
    } else {
      this.workspaceKey = workspaceKey;
    }
  }
  _validateStore(stores) {
    if (!stores || !Array.isArray(stores)) return;
    const validatedStores = [];
    stores.forEach(store => {
      if (!store.storeId) {
        console.log('SuprSendInbox: storeId is mandatory if stores are used');
        return;
      }
      const query = store == null ? void 0 : store.query;
      let read;
      let tags = [];
      let categories = [];
      let archived;
      if (typeof (query == null ? void 0 : query.read) === 'boolean') {
        read = query.read;
      }
      if (typeof (query == null ? void 0 : query.archived) === 'boolean') {
        archived = query.archived;
      }
      if (typeof (query == null ? void 0 : query.tags) === 'string') {
        tags = [query.tags];
      } else if (Array.isArray(query == null ? void 0 : query.tags)) {
        tags = query == null ? void 0 : query.tags.filter(tag => {
          return typeof tag === 'string';
        });
      }
      if (typeof (query == null ? void 0 : query.categories) === 'string') {
        categories = [query.categories];
      } else if (Array.isArray(query == null ? void 0 : query.categories)) {
        categories = query == null ? void 0 : query.categories.filter(category => {
          return typeof category === 'string';
        });
      }
      validatedStores.push({
        storeId: store.storeId,
        label: store.label || store.storeId,
        query: {
          archived,
          read,
          tags,
          categories
        }
      });
    });
    this.stores = validatedStores;
  }
  _validatePageSize(pageSize) {
    if (pageSize && typeof pageSize === 'number') {
      const MAX_ALLOWED_PAGE_SIZE = 50;
      const validatedPageSize = pageSize <= MAX_ALLOWED_PAGE_SIZE ? pageSize : MAX_ALLOWED_PAGE_SIZE;
      configurationStore.setState({
        pageSize: validatedPageSize
      });
    }
  }
  _initializeStoreState() {
    const default_store = 'default_store';
    const initialStoreData = {
      notifications: [],
      unseenCount: 0,
      isFirstCall: true
    };
    if (this.stores && Array.isArray(this.stores) && this.stores.length > 0) {
      const finalStores = {};
      this.stores.map(store => {
        finalStores[store.storeId] = _extends({}, initialStoreData);
      });
      notificationStore.setState({
        stores: finalStores,
        activeStoreId: this.stores[0].storeId
      });
    } else {
      notificationStore.setState({
        stores: {
          [default_store]: _extends({}, initialStoreData)
        },
        activeStoreId: default_store
      });
    }
    // needed as wait for even listener to register after initialization
    setTimeout(() => {
      this.emitter.emit('sync_notif_store');
    }, 0);
  }
  _startExipryCheck() {
    var _this = this;
    if (this._expiryTimerId) return;
    this._expiryTimerId = setInterval(async function () {
      const notifData = notificationStore.getState();
      const storeNotifsData = notifData.stores;
      let hasExpired = false;
      for (let store in storeNotifsData) {
        let notifications = storeNotifsData[store].notifications;
        notifications = notifications.filter(notification => {
          const expired = notification.expiry ? Date.now() > notification.expiry : false;
          if (expired) {
            hasExpired = true;
            return false;
          } else {
            return true;
          }
        });
        storeNotifsData[store].notifications = notifications;
      }
      if (hasExpired) {
        notificationStore.setState({
          stores: storeNotifsData
        });
        await _this.feed.getNotificationsCount();
        _this.emitter.emit('sync_notif_store');
      }
    }, 30000);
  }
  get client() {
    if (this.distinctId && this.subscriberId) {
      if (!this._client) {
        this._client = new ApiClient(this);
      }
    }
    return this._client;
  }
  identifyUser(distinctId, subscriberId) {
    this.distinctId = distinctId;
    this.subscriberId = subscriberId;
  }
  changeActiveStore(storeId) {
    var _storeData$stores;
    const storeData = notificationStore.getState();
    const newStores = {};
    if (storeData.activeStoreId === storeId) return;
    if (!((_storeData$stores = storeData.stores) != null && _storeData$stores[storeId])) return;
    for (let _storeId in storeData.stores) {
      const store = storeData.stores[_storeId];
      const storeNotifications = store.notifications.slice(0, 20);
      newStores[_storeId] = {
        notifications: storeNotifications,
        unseenCount: store.unseenCount,
        isFirstCall: store.isFirstCall
      };
    }
    notificationStore.setState({
      activeStoreId: storeId,
      stores: newStores,
      pageNumber: 1,
      hasNext: true,
      initialLoading: false,
      fetchMoreLoading: false,
      initialFetchTime: null
    });
    if (this.client) {
      this.feed.fetchNotifications();
    }
  }
  resetUser() {
    var _this$_client;
    notificationStore.setState({
      unseenCount: 0,
      pageNumber: 1,
      hasNext: true,
      initialLoading: false,
      fetchMoreLoading: false,
      initialFetchTime: null
    });
    this._initializeStoreState();
    (_this$_client = this._client) == null ? void 0 : _this$_client.socket.disconnect();
    this.distinctId = undefined;
    this.subscriberId = undefined;
    this._client = undefined;
    clearInterval(this._expiryTimerId);
    this._expiryTimerId = undefined;
    this.feed = new Inbox(this);
  }
}

export { SuprSendInbox as default };
//# sourceMappingURL=index.modern.js.map
